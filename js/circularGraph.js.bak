/**
 * Grafo circular en D3.js que muestra las relaciones entre:
 * - Nivel 1 (centro): Épocas de platillos
 * - Nivel 2 (medio): Orígenes de platillos
 * - Nivel 3 (exterior): Nombres de platillos
 * 
 * El grafo se filtra dinámicamente según el ingrediente en foco:
 * - Maíz, Frijol, Chile, Calabaza o Cacao
 */
// Esperamos a que el DOM esté completamente cargado
document.addEventListener('DOMContentLoaded', function() {
    console.log('Inicializando grafo circular...');
    
    // Función para asegurar que existe el contenedor
    function ensureContainer() {
        // Verificar si el contenedor existe
        let networkContainer = document.getElementById('network');
        
        // Si no existe, intentar encontrar o crear el contenedor
        if (!networkContainer) {
            console.log('Contenedor #network no encontrado, intentando crear uno...');
            
            // Buscar el contenedor .visualization-container
            const vizContainer = document.querySelector('.visualization-container');
            
            if (vizContainer) {
                console.log('Contenedor .visualization-container encontrado, creando #network dentro');
                networkContainer = document.createElement('div');
                networkContainer.id = 'network';
                networkContainer.style.width = '100%';
                networkContainer.style.height = '800px';
                networkContainer.style.border = '3px solid red';  // Borde visible para depuración
                networkContainer.style.backgroundColor = '#ffffff';
                vizContainer.innerHTML = ''; // Limpiar cualquier contenido previo
                vizContainer.appendChild(networkContainer);
            } else {
                console.error('No se encontró .visualization-container, no se puede crear el grafo');
                
                // Intentar buscar en .sticky-image-sankey
                const sankeyContainer = document.querySelector('.sticky-image-sankey');
                if (sankeyContainer) {
                    console.log('Contenedor .sticky-image-sankey encontrado, creando .visualization-container y #network dentro');
                    
                    // Crear visualization-container
                    const newVizContainer = document.createElement('div');
                    newVizContainer.className = 'visualization-container';
                    newVizContainer.style.width = '100%';
                    newVizContainer.style.height = '800px';
                    newVizContainer.style.border = '3px solid green';
                    
                    // Crear network dentro
                    networkContainer = document.createElement('div');
                    networkContainer.id = 'network';
                    networkContainer.style.width = '100%';
                    networkContainer.style.height = '800px';
                    networkContainer.style.border = '3px solid red';
                    networkContainer.style.backgroundColor = '#ffffff';
                    
                    // Añadir al DOM
                    newVizContainer.appendChild(networkContainer);
                    sankeyContainer.innerHTML = '';
                    sankeyContainer.appendChild(newVizContainer);
                }
            }
        } else {
            console.log('Contenedor #network encontrado correctamente');
        }
        
        return !!document.getElementById('network');
    }
    
    // Función para verificar si el grafo ya existe y regenerarlo
    function regenerateGraph() {
        // Verificar y asegurar que el contenedor existe
        if (ensureContainer()) {
            console.log('Verificando estado del grafo y regenerando si es necesario...');
            if (!document.querySelector('#network svg')) {
                console.log('Grafo no encontrado en el DOM, iniciando creación...');
                initGraph();
            }
        } else {
            console.error('No se pudo crear el contenedor para el grafo');
        }
    }
    
    // Llamar a regenerar el grafo cuando la página cambie de tamaño
    window.addEventListener('resize', regenerateGraph);
    
    // Asegurar contenedor inmediatamente
    ensureContainer();
    
    // Función principal de inicialización del grafo
    function initGraph() {
    // Asegurarse de que D3 está disponible
    if (!window.d3) {
        console.error('D3.js no está cargado. Por favor incluya la biblioteca D3 antes de este script.');
        return;
    }
    
    // Verificar que el contenedor del grafo existe
    const networkContainer = document.getElementById('network');
    if (!networkContainer) {
        console.error('Error: No se encontró el contenedor #network para el grafo circular.');
        
        // Intentar crear el contenedor si no existe
        const vizContainer = document.querySelector('.visualization-container');
        if (vizContainer) {
            console.log('Creando contenedor #network dentro de .visualization-container');
            const newNetworkDiv = document.createElement('div');
            newNetworkDiv.id = 'network';
            newNetworkDiv.style.width = '100%';
            newNetworkDiv.style.height = '800px'; // Altura suficiente para visualizar
            vizContainer.appendChild(newNetworkDiv);
        } else {
            console.error('No se encontró ni siquiera el contenedor .visualization-container');
            return; // No podemos continuar sin un contenedor
        }
    } else {
        console.log('Contenedor #network encontrado correctamente');
    }
    
    // Ingredientes principales para filtrado
    const INGREDIENTES_PRINCIPALES = [
        'MAÍZ', 'FRIJOL', 'CHILE', 'CALABAZA', 'CACAO'
    ];
    
    // Variable global para el ingrediente actualmente seleccionado
    let ingredienteActivo = null;
    
    // Dimensiones y configuración - Adaptamos al contenedor y pantalla disponible
    const container = document.getElementById('network');
    const containerWidth = container.clientWidth || window.innerWidth * 0.75;
    const containerHeight = container.clientHeight || window.innerHeight * 0.8;
    
    // Utilizar todo el espacio disponible sin exceder el contenedor
    const width = containerWidth - 40; // Margen para evitar cortes
    const height = containerHeight - 40; // Margen para evitar cortes
    
    console.log(`Creando grafo con dimensiones: ${width}x${height}`);
    
    // Radio proporcional a la dimensión más pequeña - reducido para dar más espacio
    const radius = Math.min(width, height) / 2 - 100;
    
    // Radios para cada nivel - Ajustados para mejor visibilidad y más espacio
    const radiusLevel1 = radius * 0.2; // Centro más pequeño
    const radiusLevel2 = radius * 0.5; // Nivel medio más compacto
    const radiusLevel3 = radius * 0.85; // Exterior ligeramente más cercano
    
    // Establecer dimensiones del contenedor
    container.style.width = '100%';
    container.style.height = '100%';
    
    // Limpiar el contenedor antes de crear el SVG
    d3.select('#network').html('');
    
    console.log('Creando el SVG para el grafo circular...');
    
    // Crear el contenedor SVG con funcionalidad de zoom (sin borde)
    const zoomContainer = d3.select('#network')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('style', 'max-width: 100%; height: auto; background-color: white;'); // Sin borde
        
    // Añadir grupo principal que será afectado por el zoom
    const svg = zoomContainer.append('g')
        .attr('transform', `translate(${Math.floor(width / 2)}, ${Math.floor(height / 2)})`);
        
    // Configurar el zoom
    const zoom = d3.zoom()
        .scaleExtent([0.5, 5])  // Limita el nivel de zoom entre 0.5x y 5x
        .on("zoom", (event) => {
            svg.attr("transform", `translate(${width/2 + event.transform.x}, ${height/2 + event.transform.y}) scale(${event.transform.k})`);
        });
        
    // Activar el zoom en el SVG
    zoomContainer.call(zoom);
    
    // Añadir instrucciones de zoom
    zoomContainer.append('text')
        .attr('x', 20)
        .attr('y', 30)
        .attr('fill', '#243360')
        .style('font-size', '14px')
        .text('Usa la rueda del ratón para hacer zoom y arrastrar para mover');

    // Quitamos el título del SVG ya que se pierde al hacer zoom

    // Crear grupo para los círculos guía (opcional, para referencia visual)
    const guideCircles = svg.append('g').attr('class', 'guide-circles');
    
    // Círculos guía (opcional) - Color adaptado para fondo blanco
    guideCircles.append('circle')
        .attr('r', radiusLevel1)
        .attr('fill', 'none')
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,4')
        .attr('opacity', 0.5);
        
    guideCircles.append('circle')
        .attr('r', radiusLevel2)
        .attr('fill', 'none')
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,4')
        .attr('opacity', 0.5);
        
    guideCircles.append('circle')
        .attr('r', radiusLevel3)
        .attr('fill', 'none')
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,4')
        .attr('opacity', 0.5);

    // Crear grupos principales para los elementos visuales
    const linkGroup = svg.append('g').attr('class', 'links');
    const nodeGroup = svg.append('g').attr('class', 'nodes');
    const labelGroup = svg.append('g').attr('class', 'labels');
    
    // Variables globales
    let simulation;
    let nodes = [];
    let links = [];
    let nodesFiltered = [];
    let linksFiltered = [];
    let nodeElements, linkElements, labelElements;
    
    // Función para actualizar el ingrediente activo (expuesta globalmente)
    window.actualizarIngredienteGrafo = function(ingrediente) {
        console.log('Filtrar grafo por ingrediente:', ingrediente);
        
        // Si no hay ingrediente o está vacío, mostrar grafo completo
        if (!ingrediente || ingrediente.trim() === '') {
            console.log('Ingrediente vacío o nulo, mostrando grafo completo');
            ingredienteActivo = null;
        } else {
            // Simplemente convertir a mayúsculas para la búsqueda
            ingredienteActivo = ingrediente.trim().toUpperCase();
            
            // Simplificar para los 5 ingredientes principales
            if (ingredienteActivo === 'MAÍZ') ingredienteActivo = 'MAÍZ';
            if (ingredienteActivo === 'FRÍJOL') ingredienteActivo = 'FRIJOL';
            
            console.log('Ingrediente normalizado para búsqueda:', ingredienteActivo);
        }
        if (window.grafoData && window.grafoInicializado) {
            // El grafo está inicializado, podemos filtrar
            filtrarPorIngrediente(ingredienteActivo);
            actualizarVisualizacion(false); // Sin forma de ingrediente
        } else {
            console.log('Esperando a que el grafo se inicialice para filtrar por:', ingrediente);
            // Intentar de nuevo después de un breve retraso si los datos están disponibles pero no inicializado
            if (window.grafoData && !window.grafoInicializado) {
                setTimeout(() => {
                    if (window.grafoInicializado) {
                        filtrarPorIngrediente(ingredienteActivo);
                        actualizarVisualizacion(false); // Sin forma de ingrediente
                    }
                }, 500);
            }
        }
    };
    
    // Función para determinar colores de los nodos según el nivel
    function getNodeColor(node) {
        if (node.level === 1) return '#243360';  // Época (centro)
        if (node.level === 2) return '#83572B';  // Origen (medio)
        
        // Todos los platillos (nivel 3) del mismo color
        return '#608CA8';
    }
    
    // Función para determinar el tamaño de los nodos - Recalculado según el grafo filtrado
    function getNodeRadius(node) {
        // Calcular el número de conexiones en el grafo filtrado actual
        let connectionCount = 0;
        
        // Contar las conexiones en los enlaces filtrados
        linksFiltered.forEach(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            
            if (sourceId === node.id || targetId === node.id) {
                connectionCount++;
            }
        });
        
        // Aplicar escala según el nivel
        if (node.level === 1) {
            // Épocas: más grandes
            return Math.max(14, Math.min(40, 15 + connectionCount));
        }
        if (node.level === 2) {
            // Orígenes: tamaño medio
            return Math.max(10, Math.min(20, 10 + connectionCount / 3));
        }
        
        // Platillos: tamaño pequeño pero uniforme
        return 6;
    }
    
    // Funciones para controlar el arrastre de nodos
    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        // No resetear d.fx y d.fy para mantener la posición
    }
    
    // Crear tooltip mejorado
    const tooltip = d3.select('body').append('div')
        .attr('class', 'graph-tooltip')
        .style('position', 'absolute')
        .style('color', '#333') // Texto oscuro
        .style('font-size', '12px')
        .style('pointer-events', 'none')
        .style('opacity', 0)
        .style('transition', 'opacity 0.2s linear');
    
    // Función para filtrar por ingrediente según el scroll
    function filtrarPorIngrediente(ingrediente) {
        if (!window.grafoData) {
            console.warn('No hay datos de grafo disponibles para filtrar');
            return;
        }
        
        // Actualizamos el ingrediente activo
        ingredienteActivo = ingrediente;
        
        console.log(`Actualizando filtro - Ingrediente activo: ${ingredienteActivo}`);
        
        // Si no hay ingrediente activo (último paso), mostrar todo el grafo
        if (!ingredienteActivo) {
            console.log('Mostrando grafo completo sin filtros');
            nodesFiltered = [...nodes];
            linksFiltered = [...links];
            actualizarVisualizacion(false); // Sin forma especial para grafo completo
            return;
        }
        
        console.log(`Filtrando grafo por ingrediente: ${ingredienteActivo}`);
        
        // ================ FILTRADO ESTRICTO ================
        // Solo mostrar los nodos y enlaces relacionados con este ingrediente
        
        // Paso 1: Identificar platillos que contienen el ingrediente específico
        const platillosConIngrediente = new Set();
        
        console.log(`Buscando platillos con ingrediente que contenga: ${ingredienteActivo}`);
        
        nodes.forEach(node => {
            if (node.level === 3 && node.ingredientes && node.ingredientes.length > 0) {
                // Buscar si alguno de los ingredientes CONTIENE el texto buscado
                // Por ejemplo, "CHILE SECO" contiene "CHILE"
                const tieneIngrediente = node.ingredientes && Array.isArray(node.ingredientes) && 
                    node.ingredientes.some(ing => 
                        ing && typeof ing === 'string' && ing.includes(ingredienteActivo)
                    );
                
                if (tieneIngrediente) {
                    platillosConIngrediente.add(node.id);
                    node.isRelevant = true; // Marcar como relevante
                } else {
                    node.isRelevant = false;
                }
            } else if (node.level === 3) {
                node.isRelevant = false;
            }
        });
        
        console.log(`Encontrados ${platillosConIngrediente.size} platillos con ingrediente: ${ingredienteActivo}`);
        
        // Paso 2: Identificar orígenes relacionados con estos platillos
        const origenesRelacionados = new Set();
        const enlacesOrigenPlatillo = [];
        
        links.forEach(link => {
            // Verificar si es un enlace entre origen y platillo
            if (link.type === 'origen-platillo') {
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                if (platillosConIngrediente.has(targetId)) {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    origenesRelacionados.add(sourceId);
                    enlacesOrigenPlatillo.push(link); // Guardar este enlace
                }
            }
        });
        
        console.log(`Encontrados ${origenesRelacionados.size} orígenes relacionados con ${ingredienteActivo}`);
        
        // Marcar orígenes como relevantes
        nodes.forEach(node => {
            if (node.level === 2) {
                node.isRelevant = origenesRelacionados.has(node.id);
            }
        });
        
        // Paso 3: Identificar épocas relacionadas con estos orígenes
        const epocasRelacionadas = new Set();
        const enlacesEpocaOrigen = [];
        
        links.forEach(link => {
            if (link.type === 'epoca-origen') {
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                if (origenesRelacionados.has(targetId)) {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    epocasRelacionadas.add(sourceId);
                    enlacesEpocaOrigen.push(link); // Guardar este enlace
                }
            }
        });
        
        console.log(`Encontradas ${epocasRelacionadas.size} épocas relacionadas con ${ingredienteActivo}`);
        
        // Marcar épocas como relevantes
        nodes.forEach(node => {
            if (node.level === 1) {
                node.isRelevant = epocasRelacionadas.has(node.id);
            }
        });
        
        // Paso 4: Crear la lista filtrada de nodos y enlaces
        
        // Filtrar solo los nodos relevantes
        nodesFiltered = nodes.filter(node => {
            if (node.level === 1) return epocasRelacionadas.has(node.id);
            if (node.level === 2) return origenesRelacionados.has(node.id);
            if (node.level === 3) return platillosConIngrediente.has(node.id);
            return false;
        });
        
        // Combinar los enlaces relevantes
        linksFiltered = [...enlacesEpocaOrigen, ...enlacesOrigenPlatillo];
        
        // Ajustar opacidad en los enlaces filtrados
        linksFiltered.forEach(link => {
            link.isRelevant = true;
            link.opacity = 0.4; // Opacidad 40% para los enlaces relevantes
        });
        
        console.log(`Filtrado completado: ${nodesFiltered.length} nodos y ${linksFiltered.length} enlaces relevantes`);
        
        // Si no hay suficientes elementos para mostrar, volver al filtrado original
        if (nodesFiltered.length < 5 || linksFiltered.length < 4) {
            console.log('Muy pocos elementos para mostrar, volviendo al filtrado visual');
            
            // Revertir al filtrado visual (original)
            nodesFiltered = [...nodes];
            linksFiltered = [...links];
            
            // Marcar enlaces como relevantes o no
            linksFiltered.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                
                if (link.type === 'epoca-origen') {
                    // Enlace entre época y origen
                    link.isRelevant = epocasRelacionadas.has(sourceId) && origenesRelacionados.has(targetId);
                } else if (link.type === 'origen-platillo') {
                    // Enlace entre origen y platillo
                    link.isRelevant = origenesRelacionados.has(sourceId) && platillosConIngrediente.has(targetId);
                } else {
                    link.isRelevant = false;
                }
                
                // Marcar el enlace como invisible si no es relevante
                link.opacity = link.isRelevant ? 0.4 : 0.05; // 40% para enlaces relevantes
            });
        }
    }
    
    // Código de máscaras SVG eliminado
    
    // Obtener coordenadas para formar la silueta de un ingrediente
    async function obtenerCoordenadasFormaIngrediente(ingrediente, numPuntos) {
        const centerX = width / 2;
        const centerY = height / 2;
        const radioBase = Math.min(width, height) / 3;
        let coords = [];
        
        // Formas detalladas para cada ingrediente
        switch(ingrediente.toLowerCase()) {
            case 'maiz':
                // Cargar y usar la máscara SVG para el maíz si está disponible
                const pathData = await cargarSVG('maiz');
                
                if (pathData) {
                    // Convertir el path SVG a puntos
                    try {
                        // Crear un path temporal para obtener los puntos
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        path.setAttribute("d", pathData);
                        
                        // Necesitamos añadir el path temporalmente al DOM para que getTotalLength funcione
                        const tempSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        tempSvg.setAttribute("width", "1000");
                        tempSvg.setAttribute("height", "1000");
                        tempSvg.style.position = "absolute";
                        tempSvg.style.visibility = "hidden";
                        tempSvg.appendChild(path);
                        document.body.appendChild(tempSvg);
                        
                        try {
                            // Obtener longitud del path
                            const pathLength = path.getTotalLength();
                            
                            if (isFinite(pathLength) && pathLength > 0) {
                                // Obtener el BBox para centrado
                                const bbox = path.getBBox();
                                
                                // Ajustar el escalado basado en el tamaño del bounding box
                                const scale = radioBase / Math.max(bbox.width, bbox.height) * 1.8;
                                
                                // Muestrear puntos a lo largo del path
                                for (let i = 0; i < numPuntos; i++) {
                                    try {
                                        const point = path.getPointAtLength(i / numPuntos * pathLength);
                                        
                                        if (point && isFinite(point.x) && isFinite(point.y)) {
                                            // Escalar y centrar en el canvas
                                            // Transformamos de coordenadas del SVG a coordenadas del canvas
                                            const x = centerX + (point.x - (bbox.x + bbox.width/2)) * scale;
                                            const y = centerY + (point.y - (bbox.y + bbox.height/2)) * scale;
                                            
                                            if (isFinite(x) && isFinite(y)) {
                                                coords.push({ x, y });
                                            }
                                        }
                                    } catch (pointError) {
                                        // Saltamos este punto
                                    }
                                }
                            } else {
                                throw new Error(`Path inválido, longitud: ${pathLength}`);
                            }
                        } catch (pathError) {
                            console.warn(`Error procesando path: ${pathError.message}`);
                            
                            // Si falla, creamos puntos basados en el BBox
                            try {
                                const bbox = path.getBBox();
                                const scale = radioBase / Math.max(bbox.width, bbox.height) * 1.8;
                                
                                // Generar puntos alrededor del perímetro
                                for (let i = 0; i < numPuntos; i++) {
                                    const angle = (i / numPuntos) * 2 * Math.PI;
                                    // Crear una forma ovalada
                                    const x = Math.cos(angle) * scale * bbox.width/2;
                                    const y = Math.sin(angle) * scale * bbox.height/2;
                                    coords.push({ x, y });
                                }
                            } catch (bboxError) {
                                throw bboxError;
                            }
                        } finally {
                            // Limpieza
                            document.body.removeChild(tempSvg);
                        }
                        
                        // Si obtuvimos puntos, devolvemos
                        if (coords.length > 0) {
                            console.log(`Usando forma SVG para maíz - ${coords.length} puntos generados`);
                            return coords;
                        }
                    } catch (error) {
                        console.error("Error procesando SVG maíz:", error);
                        // Continuar con la versión matemática si falla el SVG
                    }
                }
                
                console.log("Usando forma matemática para maíz (fallback)");
                
                // Forma matemática de respaldo si falla el SVG
                const mazorcaLength = radioBase * 1.8;
                const mazorcaWidth = radioBase * 0.8;
                
                for (let i = 0; i < numPuntos; i++) {
                    const t = (i / numPuntos) * 2 * Math.PI;
                    
                    let x, y;
                    
                    if (t < Math.PI) {
                        const factor = 0.8 + 0.7 * Math.pow(Math.sin(t), 2);
                        x = centerX + mazorcaWidth * Math.cos(t) * 0.8;
                        y = centerY - mazorcaLength * Math.sin(t) * factor;
                    } else {
                        const factor = 0.9 - 0.1 * Math.sin(t * 2);
                        x = centerX + mazorcaWidth * Math.cos(t) * 0.7;
                        y = centerY - mazorcaLength * Math.sin(t) * factor;
                    }
                    
                    const grain = 0.05 * Math.sin(t * 20) * Math.sin(t * 7);
                    x += grain * mazorcaWidth;
                    
                    coords.push({ x, y });
                }
                break;
                
            case 'chile':
                // Intentar cargar SVG de chile
                const pathDataChile = await cargarSVG('chile');
                
                if (pathDataChile) {
                    try {
                        // Crear un path temporal para obtener los puntos
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        path.setAttribute("d", pathDataChile);
                        
                        // Añadir temporalmente al DOM
                        const tempSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        tempSvg.setAttribute("width", "1000");
                        tempSvg.setAttribute("height", "1000");
                        tempSvg.style.position = "absolute";
                        tempSvg.style.visibility = "hidden";
                        tempSvg.appendChild(path);
                        document.body.appendChild(tempSvg);
                        
                        try {
                            // Obtener longitud del path
                            const pathLength = path.getTotalLength();
                            
                            if (isFinite(pathLength) && pathLength > 0) {
                                // Obtener el BBox para centrado
                                const bbox = path.getBBox();
                                
                                // Ajustar el escalado basado en el tamaño del bounding box
                                const scale = radioBase / Math.max(bbox.width, bbox.height) * 1.8;
                                
                                // Muestrear puntos a lo largo del path
                                for (let i = 0; i < numPuntos; i++) {
                                    try {
                                        const point = path.getPointAtLength(i / numPuntos * pathLength);
                                        
                                        if (point && isFinite(point.x) && isFinite(point.y)) {
                                            // Escalar respecto al centro del SVG
                                            // El origen ahora será (0,0) y escalaremos desde ahí
                                            const x = (point.x - (bbox.x + bbox.width/2)) * scale;
                                            const y = (point.y - (bbox.y + bbox.height/2)) * scale;
                                            
                                            if (isFinite(x) && isFinite(y)) {
                                                coords.push({ x, y });
                                            }
                                        }
                                    } catch (pointError) {
                                        // Saltamos este punto
                                    }
                                }
                            }
                        } finally {
                            // Limpieza
                            document.body.removeChild(tempSvg);
                        }
                        
                        // Si obtuvimos puntos, devolvemos
                        if (coords.length > 0) {
                            console.log(`Usando forma SVG para chile - ${coords.length} puntos generados`);
                            return coords;
                        }
                    } catch (error) {
                        console.error("Error procesando SVG chile:", error);
                        // Continuar con versión matemática
                    }
                }
                
                console.log("Usando forma matemática para chile (fallback)");
                
                // Forma realista de chile
                for (let i = 0; i < numPuntos; i++) {
                    const t = (i / numPuntos) * 2 * Math.PI;
                    
                    // Crear forma de chile (ancho arriba, estrecho abajo, punta pronunciada)
                    let x, y;
                    
                    // Parámetros del chile
                    const chileLength = radioBase * 1.6;
                    const chileTopWidth = radioBase * 0.7;
                    const chileBottomWidth = radioBase * 0.15;
                    
                    // Calcular coordenadas
                    if (t < Math.PI) {
                        // Mitad superior: desde el tallo hasta el ancho máximo
                        const widthFactor = chileTopWidth * (0.5 + 0.5 * Math.sin(t)); // Ancho en la parte superior
                        x = centerX + widthFactor * Math.cos(t);
                        y = centerY - chileLength * Math.sin(t) * (0.7 + 0.3 * Math.sin(t));
                    } else {
                        // Mitad inferior: desde el ancho máximo hasta la punta
                        // Crear una punta aguda al reducir el ancho rápidamente
                        const widthFactor = chileBottomWidth * (2 - Math.sin(t));
                        x = centerX + widthFactor * Math.cos(t);
                        y = centerY - chileLength * Math.sin(t) * (0.7 + 0.3 * Math.sin(t));
                    }
                    
                    // Agregar una leve curvatura típica de los chiles
                    x += 0.1 * radioBase * Math.sin(t * 0.5);
                    
                    coords.push({ x, y });
                }
                break;
                
            case 'frijol':
                // Intentar cargar SVG de frijol
                const pathDataFrijol = await cargarSVG('frijol');
                
                if (pathDataFrijol) {
                    try {
                        // Crear un path temporal para obtener los puntos
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        path.setAttribute("d", pathDataFrijol);
                        
                        // Añadir temporalmente al DOM
                        const tempSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        tempSvg.setAttribute("width", "1000");
                        tempSvg.setAttribute("height", "1000");
                        tempSvg.style.position = "absolute";
                        tempSvg.style.visibility = "hidden";
                        tempSvg.appendChild(path);
                        document.body.appendChild(tempSvg);
                        
                        try {
                            // Obtener longitud del path
                            const pathLength = path.getTotalLength();
                            
                            if (isFinite(pathLength) && pathLength > 0) {
                                // Obtener el BBox para centrado
                                const bbox = path.getBBox();
                                
                                // Ajustar el escalado basado en el tamaño del bounding box
                                const scale = radioBase / Math.max(bbox.width, bbox.height) * 1.8;
                                
                                // Muestrear puntos a lo largo del path
                                for (let i = 0; i < numPuntos; i++) {
                                    try {
                                        const point = path.getPointAtLength(i / numPuntos * pathLength);
                                        
                                        if (point && isFinite(point.x) && isFinite(point.y)) {
                                            // Escalar respecto al centro del SVG
                                            // El origen ahora será (0,0) y escalaremos desde ahí
                                            const x = (point.x - (bbox.x + bbox.width/2)) * scale;
                                            const y = (point.y - (bbox.y + bbox.height/2)) * scale;
                                            
                                            if (isFinite(x) && isFinite(y)) {
                                                coords.push({ x, y });
                                            }
                                        }
                                    } catch (pointError) {
                                        // Saltamos este punto
                                    }
                                }
                            }
                        } finally {
                            // Limpieza
                            document.body.removeChild(tempSvg);
                        }
                        
                        // Si obtuvimos puntos, devolvemos
                        if (coords.length > 0) {
                            console.log(`Usando forma SVG para frijol - ${coords.length} puntos generados`);
                            return coords;
                        }
                    } catch (error) {
                        console.error("Error procesando SVG frijol:", error);
                        // Continuar con versión matemática
                    }
                }
                
                console.log("Usando forma matemática para frijol (fallback)");
                
                // Forma realista de frijol (forma de riñón)
                for (let i = 0; i < numPuntos; i++) {
                    const t = (i / numPuntos) * 2 * Math.PI;
                    
                    // Parámetros del frijol
                    const frijolWidth = radioBase;
                    const frijolHeight = radioBase * 0.65;
                    
                    // Base elíptica
                    let x = centerX + frijolWidth * Math.cos(t);
                    let y = centerY + frijolHeight * Math.sin(t);
                    
                    // Agregar muesca característica del frijol
                    if (t > Math.PI * 0.7 && t < Math.PI * 1.3) {
                        // Crear la muesca en la parte media de un lado
                        const indentFactor = 0.4 * Math.sin((t - Math.PI * 0.7) * 5);
                        x -= indentFactor * frijolWidth;
                    }
                    
                    // Agregar textura sutil
                    const texture = 0.02 * Math.sin(t * 30);
                    x += texture * frijolWidth;
                    y += texture * frijolHeight;
                    
                    coords.push({ x, y });
                }
                break;
                
            case 'calabaza':
                // Intentar cargar SVG de calabaza
                const pathDataCalabaza = await cargarSVG('calabaza');
                
                if (pathDataCalabaza) {
                    try {
                        // Crear un path temporal para obtener los puntos
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        path.setAttribute("d", pathDataCalabaza);
                        
                        // Añadir temporalmente al DOM
                        const tempSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        tempSvg.setAttribute("width", "1000");
                        tempSvg.setAttribute("height", "1000");
                        tempSvg.style.position = "absolute";
                        tempSvg.style.visibility = "hidden";
                        tempSvg.appendChild(path);
                        document.body.appendChild(tempSvg);
                        
                        try {
                            // Obtener longitud del path
                            const pathLength = path.getTotalLength();
                            
                            if (isFinite(pathLength) && pathLength > 0) {
                                // Obtener el BBox para centrado
                                const bbox = path.getBBox();
                                
                                // Ajustar el escalado basado en el tamaño del bounding box
                                const scale = radioBase / Math.max(bbox.width, bbox.height) * 1.8;
                                
                                // Muestrear puntos a lo largo del path
                                for (let i = 0; i < numPuntos; i++) {
                                    try {
                                        const point = path.getPointAtLength(i / numPuntos * pathLength);
                                        
                                        if (point && isFinite(point.x) && isFinite(point.y)) {
                                            // Escalar respecto al centro del SVG
                                            // El origen ahora será (0,0) y escalaremos desde ahí
                                            const x = (point.x - (bbox.x + bbox.width/2)) * scale;
                                            const y = (point.y - (bbox.y + bbox.height/2)) * scale;
                                            
                                            if (isFinite(x) && isFinite(y)) {
                                                coords.push({ x, y });
                                            }
                                        }
                                    } catch (pointError) {
                                        // Saltamos este punto
                                    }
                                }
                            }
                        } finally {
                            // Limpieza
                            document.body.removeChild(tempSvg);
                        }
                        
                        // Si obtuvimos puntos, devolvemos
                        if (coords.length > 0) {
                            console.log(`Usando forma SVG para calabaza - ${coords.length} puntos generados`);
                            return coords;
                        }
                    } catch (error) {
                        console.error("Error procesando SVG calabaza:", error);
                        // Continuar con versión matemática
                    }
                }
                
                console.log("Usando forma matemática para calabaza (fallback)");
                
                // Forma realista de calabaza (achatada con gajos)
                for (let i = 0; i < numPuntos; i++) {
                    const t = (i / numPuntos) * 2 * Math.PI;
                    
                    // Parámetros de la calabaza
                    const calabazaWidth = radioBase * 1.2;
                    const calabazaHeight = radioBase * 0.85;
                    
                    // Base elíptica achatada
                    let x = centerX + calabazaWidth * Math.cos(t);
                    let y = centerY + calabazaHeight * Math.sin(t);
                    
                    // Agregar los gajos característicos de la calabaza
                    const ridges = 0.12 * Math.sin(t * 8);
                    x += ridges * calabazaWidth * Math.cos(t);
                    y += ridges * calabazaHeight * Math.sin(t);
                    
                    // Agregar tallo en la parte superior
                    if (t > Math.PI * 0.8 && t < Math.PI * 1.2) {
                        // Crear un pequeño tallo en la parte superior
                        y -= 0.15 * calabazaHeight;
                    }
                    
                    coords.push({ x, y });
                }
                break;
                
            case 'cacao':
                // Intentar cargar SVG de cacao
                const pathDataCacao = await cargarSVG('cacao');
                
                if (pathDataCacao) {
                    try {
                        // Crear un path temporal para obtener los puntos
                        const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                        path.setAttribute("d", pathDataCacao);
                        
                        // Añadir temporalmente al DOM
                        const tempSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                        tempSvg.setAttribute("width", "1000");
                        tempSvg.setAttribute("height", "1000");
                        tempSvg.style.position = "absolute";
                        tempSvg.style.visibility = "hidden";
                        tempSvg.appendChild(path);
                        document.body.appendChild(tempSvg);
                        
                        try {
                            // Obtener longitud del path
                            const pathLength = path.getTotalLength();
                            
                            if (isFinite(pathLength) && pathLength > 0) {
                                // Obtener el BBox para centrado
                                const bbox = path.getBBox();
                                
                                // Ajustar el escalado basado en el tamaño del bounding box
                                const scale = radioBase / Math.max(bbox.width, bbox.height) * 1.8;
                                
                                // Muestrear puntos a lo largo del path
                                for (let i = 0; i < numPuntos; i++) {
                                    try {
                                        const point = path.getPointAtLength(i / numPuntos * pathLength);
                                        
                                        if (point && isFinite(point.x) && isFinite(point.y)) {
                                            // Escalar respecto al centro del SVG
                                            // El origen ahora será (0,0) y escalaremos desde ahí
                                            const x = (point.x - (bbox.x + bbox.width/2)) * scale;
                                            const y = (point.y - (bbox.y + bbox.height/2)) * scale;
                                            
                                            if (isFinite(x) && isFinite(y)) {
                                                coords.push({ x, y });
                                            }
                                        }
                                    } catch (pointError) {
                                        // Saltamos este punto
                                    }
                                }
                            }
                        } finally {
                            // Limpieza
                            document.body.removeChild(tempSvg);
                        }
                        
                        // Si obtuvimos puntos, devolvemos
                        if (coords.length > 0) {
                            console.log(`Usando forma SVG para cacao - ${coords.length} puntos generados`);
                            return coords;
                        }
                    } catch (error) {
                        console.error("Error procesando SVG cacao:", error);
                        // Continuar con versión matemática
                    }
                }
                
                console.log("Usando forma matemática para cacao (fallback)");
                
                // Forma realista de vaina de cacao
                for (let i = 0; i < numPuntos; i++) {
                    const t = (i / numPuntos) * 2 * Math.PI;
                    
                    // Parámetros de la vaina
                    const cacaoLength = radioBase * 1.5;
                    const cacaoWidth = radioBase * 0.6;
                    
                    // Base ovalada alargada
                    let x = centerX + cacaoWidth * Math.cos(t);
                    let y = centerY + cacaoLength * Math.sin(t);
                    
                    // Hacer puntiagudo en ambos extremos
                    const pointFactor = 0.2 * Math.pow(Math.abs(Math.sin(t)), 3);
                    y += pointFactor * cacaoLength * Math.sign(Math.sin(t));
                    
                    // Agregar surcos característicos de la vaina de cacao
                    const ridges = 0.08 * Math.sin(t * 12) * Math.sin(t * 2);
                    x += ridges * cacaoWidth;
                    
                    // Torcer ligeramente la vaina para darle naturalidad
                    x += 0.1 * cacaoWidth * Math.sin(t * 0.6);
                    
                    coords.push({ x, y });
                }
                break;
                
            default:
                // Círculo simple para casos no reconocidos
                for (let i = 0; i < numPuntos; i++) {
                    const t = (i / numPuntos) * 2 * Math.PI;
                    coords.push({
                        x: centerX + radioBase * Math.cos(t),
                        y: centerY + radioBase * Math.sin(t)
                    });
                }
        }
        
        return coords;
    }

    // Función para actualizar la visualización
    function actualizarVisualizacion(useIngredientShape = false) {
        // Mostrar información sobre el filtro actual
        let infoText;
        if (ingredienteActivo) {
            // Contar platillos que tienen este ingrediente con manejo seguro de errores
            const platillosCount = nodesFiltered.filter(n => 
                n.level === 3 && 
                n.ingredientes && 
                Array.isArray(n.ingredientes) && 
                n.ingredientes.some(ing => typeof ing === 'string' && ing.includes(ingredienteActivo))
            ).length;
            
            // Crear texto informativo detallado
            infoText = `Platillos con ${ingredienteActivo.toLowerCase()} (${platillosCount}) y sus conexiones`;
        } else {
            infoText = ''; // Quitar el título cuando se muestra la visualización completa
        }
        
        // Actualizar o crear elemento de información
        let infoElement = d3.select('#filter-info');
        if (infoElement.empty()) {
            infoElement = d3.select('#network')
                .append('div')
                .attr('id', 'filter-info')
                .style('position', 'absolute')
                .style('top', '50px')
                .style('left', '50%')
                .style('transform', 'translateX(-50%)')
                .style('background-color', '#F5F5F5')
                .style('padding', '8px 20px')
                .style('border-radius', '30px')
                .style('font-family', 'Libre Baskerville, serif')
                .style('font-size', '14px')
                .style('color', '#243360')
                .style('font-weight', 'bold')
                .style('text-align', 'center')
                .style('box-shadow', '0 2px 8px rgba(0,0,0,0.1)');
        }
        
        // Actualizar texto sin transición compleja
        infoElement.text(infoText).style('opacity', 1);
        
        // Limpiar visualizaciones previas
        linkGroup.selectAll('*').remove();
        nodeGroup.selectAll('*').remove();
        labelGroup.selectAll('*').remove();
        
        // Detener simulación anterior si existe
        if (simulation) simulation.stop();
        
        // Establecer posiciones iniciales basadas en la forma del ingrediente si es aplicable
        if (false) {
            // Código eliminado para máscaras con forma de ingrediente
            return;
        }
        
        // Caso normal: sin forma de ingrediente (o después de la animación)
        // Crear enlaces
        linkElements = linkGroup.selectAll('line')
            .data(linksFiltered)
            .enter()
            .append('line')
            .attr('stroke', d => {
                // Color según el tipo de enlace
                if (d.type === 'epoca-origen') return '#243360';
                if (d.type === 'origen-platillo') return '#83572B';
                return '#aaa';
            })
            .attr('opacity', d => {
                // Establecer opacidad
                if (ingredienteActivo) {
                    return d.isRelevant ? 0.4 : 0.05;
                }
                return 0.4;
            })
            .attr('stroke-width', d => {
                const baseWidth = Math.sqrt(d.value) * 0.7;
                if (ingredienteActivo && d.isRelevant) {
                    return baseWidth + 0.3;
                }
                return baseWidth;
            });
        
        // Crear nodos
        nodeElements = nodeGroup.selectAll('circle')
            .data(nodesFiltered)
            .enter()
            .append('circle')
            .attr('r', getNodeRadius)
            .attr('fill', getNodeColor)
            .attr('stroke', '#fff')
            .attr('stroke-width', 1)
            .attr('opacity', d => {
                if (ingredienteActivo) {
                    return d.isRelevant ? 1 : 0.3;
                }
                return 1;
            })
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));
        
        // Añadir etiquetas
        labelElements = labelGroup.selectAll('text')
            .data(nodesFiltered)
            .enter()
            .append('text')
            .style('fill', '#999999')
            .style('font-family', 'Arial, sans-serif')
            .style('font-size', d => d.level === 1 ? '13px' : '0px')
            .style('font-weight', 'normal')
            .style('pointer-events', 'none')
            .style('text-anchor', 'middle')
            .style('stroke', 'none')
            .style('paint-order', 'normal')
            .text(d => d.level === 1 ? d.name : '')
            .attr('opacity', d => d.level === 1 ? 1 : 0);
        
        // Crear nueva simulación con nodos filtrados
        simulation = d3.forceSimulation(nodesFiltered)
            .force('link', d3.forceLink(linksFiltered).id(d => d.id).distance(d => {
                // Distancias basadas en niveles para mejor estructura radial
                const sourceLevel = typeof d.source === 'object' ? d.source.level : 1;
                const targetLevel = typeof d.target === 'object' ? d.target.level : 3;
                
                if (sourceLevel === 1 && targetLevel === 2) return 50; // Épocas a orígenes
                if (sourceLevel === 2 && targetLevel === 3) return 35; // Orígenes a platillos
                return 25; // Dentro del mismo nivel
            }))
            .force('charge', d3.forceManyBody().strength(-25)) // Fuerza repulsiva moderada
            .force('x', d3.forceX().strength(0.1)) // Fuerza centralizadora
            .force('y', d3.forceY().strength(0.1)) // Fuerza centralizadora
            .force('collide', d3.forceCollide().radius(d => getNodeRadius(d) + 2).strength(0.7))
            .force('radial', d3.forceRadial(d => {
                if (d.level === 1) return radiusLevel1;
                if (d.level === 2) return radiusLevel2;
                return radiusLevel3;
            }).strength(1)) // Fuerza radial para estructura circular
            .alphaDecay(0.1) // Velocidad de convergencia
            .velocityDecay(0.3); // Amortiguación de movimiento
            
        // Actualizar en cada tick
        simulation.on('tick', () => {
            linkElements
                .attr('x1', d => isFinite(d.source.x) ? d.source.x : 0)
                .attr('y1', d => isFinite(d.source.y) ? d.source.y : 0)
                .attr('x2', d => isFinite(d.target.x) ? d.target.x : 0)
                .attr('y2', d => isFinite(d.target.y) ? d.target.y : 0);
                
            nodeElements
                .attr('cx', d => isFinite(d.x) ? d.x : 0)
                .attr('cy', d => isFinite(d.y) ? d.y : 0);
                
            labelElements
                .attr('x', d => isFinite(d.x) ? d.x : 0)
                .attr('y', d => isFinite(d.y) ? d.y + (d.level === 1 ? 30 : d.level === 2 ? 20 : 15) : 0);
        });
        
        // Configurar eventos interactivos
        configurarEventosInteractivos();
        
        // No aplicar transición de opacidad al SVG - mejor velocidad
        d3.select('#network svg g').style('opacity', 1);
        
        // No aplicar ningún posicionamiento especial para nodos nivel 2
        // Dejar que la simulación coloque los nodos naturalmente
        
        // Crear nueva simulación con nodos filtrados
        simulation = d3.forceSimulation(nodesFiltered)
            .force('link', d3.forceLink(linksFiltered).id(d => d.id).distance(d => {
                // Distancias basadas en niveles para mejor estructura radial
                const sourceLevel = typeof d.source === 'object' ? d.source.level : 1;
                const targetLevel = typeof d.target === 'object' ? d.target.level : 3;
                
                if (sourceLevel === 1 && targetLevel === 2) return 50; // Épocas a orígenes
                if (sourceLevel === 2 && targetLevel === 3) return 35; // Orígenes a platillos
                return 25; // Dentro del mismo nivel
            }))
            .force('charge', d3.forceManyBody().strength(-25)) // Fuerza repulsiva moderada
            .force('x', d3.forceX().strength(0.1)) // Fuerza centralizadora
            .force('y', d3.forceY().strength(0.1)) // Fuerza centralizadora
            .force('collide', d3.forceCollide().radius(d => getNodeRadius(d) + 2).strength(0.7))
            .force('radial', d3.forceRadial(d => {
                if (d.level === 1) return radiusLevel1;
                if (d.level === 2) return radiusLevel2;
                return radiusLevel3;
            }).strength(1)) // Fuerza radial para estructura circular
            .alphaDecay(0.1) // Velocidad de convergencia
            .velocityDecay(0.3); // Amortiguación de movimiento
        
        // Crear enlaces - Con opacidad 60%
        linkElements = linkGroup.selectAll('line')
            .data(linksFiltered)
            .enter()
            .append('line')
            .attr('stroke', d => {
                // Color según el tipo de enlace
                if (d.type === 'epoca-origen') return '#243360';
                if (d.type === 'origen-platillo') return '#83572B';
                return '#aaa';
            })
            .attr('opacity', d => {
                // Establecer opacidad base al 40%
                if (ingredienteActivo) {
                    return d.isRelevant ? 0.4 : 0.05; // 40% para enlaces relevantes
                }
                return 0.4; // 40% para todos cuando no hay filtro
            })
            .attr('stroke-width', d => {
                // Enlaces más delgados
                const baseWidth = Math.sqrt(d.value) * 0.7; // Reducción del 30%
                if (ingredienteActivo && d.isRelevant) {
                    return baseWidth + 0.3; // Ligeramente más gruesos para relevantes
                }
                return baseWidth;
            });
        
        // Crear nodos - Sin bordes amarillos
        nodeElements = nodeGroup.selectAll('circle')
            .data(nodesFiltered)
            .enter()
            .append('circle')
            .attr('r', getNodeRadius)
            .attr('fill', getNodeColor)
            .attr('stroke', '#fff')
            .attr('stroke-width', 1)
            .attr('opacity', d => {
                if (ingredienteActivo) {
                    return d.isRelevant ? 1 : 0.3; // Nodos no relevantes con menos opacidad
                }
                return 1;
            })
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));
        
        // Añadir etiquetas - Solo visibles para nivel 1 (épocas) en color gris
        labelElements = labelGroup.selectAll('text')
            .data(nodesFiltered)
            .enter()
            .append('text')
            .style('fill', '#999999') // Color gris para las leyendas
            .style('font-family', 'Arial, sans-serif')
            .style('font-size', d => d.level === 1 ? '13px' : '0px') // Tamaño reducido para nivel 1
            .style('font-weight', 'normal') // Sin negrita
            .style('pointer-events', 'none')
            .style('text-anchor', 'middle')
            .style('stroke', 'none') // Quitar borde negro
            .style('paint-order', 'normal')
            .text(d => {
                // Solo mostrar texto para nivel 1
                return d.level === 1 ? d.name : '';
            })
            .attr('opacity', d => {
                // Solo mostrar etiquetas de nivel 1 (épocas)
                return d.level === 1 ? 1 : 0;
            });
        
        // Configurar eventos de interacción
        configurarEventosInteractivos();
        
        // Actualizar la simulación en cada tick
        simulation.on('tick', () => {
            linkElements
                .attr('x1', d => isFinite(d.source.x) ? d.source.x : 0)
                .attr('y1', d => isFinite(d.source.y) ? d.source.y : 0)
                .attr('x2', d => isFinite(d.target.x) ? d.target.x : 0)
                .attr('y2', d => isFinite(d.target.y) ? d.target.y : 0);
                
            nodeElements
                .attr('cx', d => isFinite(d.x) ? d.x : 0)
                .attr('cy', d => isFinite(d.y) ? d.y : 0);
                
            labelElements
                .attr('x', d => isFinite(d.x) ? d.x : 0)
                .attr('y', d => isFinite(d.y) ? d.y + (d.level === 1 ? 30 : d.level === 2 ? 20 : 15) : 0);
        });
    }
    
    // Configurar eventos de interacción
    function configurarEventosInteractivos() {
        nodeElements.on('mouseover', function(event, d) {
            d3.select(this)
                .attr('stroke', '#243360')
                .attr('stroke-width', 2);
            
            // Mostrar enlaces conectados con mayor opacidad (80%)
            linkElements.attr('opacity', l => 
                l.source.id === d.id || l.target.id === d.id ? 0.8 : 0.1
            );
            
            // Resaltar nodos conectados
            nodeElements.attr('opacity', n => {
                // Verificar si es este nodo o está conectado a este nodo
                const isConnected = linksFiltered.some(l => 
                    (l.source.id === d.id && l.target.id === n.id) || 
                    (l.target.id === d.id && l.source.id === n.id)
                );
                return n === d || isConnected ? 1 : 0.3;
            });
            
            // Contar conexiones entrantes (in-degree) y salientes (out-degree)
            let inDegree = 0;
            let outDegree = 0;
            
            linksFiltered.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                
                // Conexiones entrantes (donde el nodo es el destino)
                if (targetId === d.id) {
                    inDegree++;
                }
                
                // Conexiones salientes (donde el nodo es el origen)
                if (sourceId === d.id) {
                    outDegree++;
                }
            });
            
            // Texto para los grados según el nivel del nodo
            let gradoTexto = "";
            
            // Añadir un separador más visible
            const separator = `<div style="height: 1px; background-color: #eee; margin: 8px 0;"></div>`;
            
            if (d.level === 1) {
                // Épocas: solo tienen salidas a orígenes
                gradoTexto = `${separator}<span style="color:#243360; font-weight:bold;">Conectado a orígenes:</span> <span style="font-size:15px; color:#000;">${outDegree}</span>`;
            } else if (d.level === 2) {
                // Orígenes: tienen entradas de épocas y salidas a platillos
                gradoTexto = `${separator}<span style="color:#243360; font-weight:bold;">Recibe de épocas:</span> <span style="font-size:15px; color:#000;">${inDegree}</span>`;
                gradoTexto += `<br><span style="color:#243360; font-weight:bold;">Conecta a platillos:</span> <span style="font-size:15px; color:#000;">${outDegree}</span>`;
            } else if (d.level === 3) {
                // Platillos: solo tienen entradas desde orígenes
                gradoTexto = `${separator}<span style="color:#243360; font-weight:bold;">Recibe de orígenes:</span> <span style="font-size:15px; color:#000;">${inDegree}</span>`;
            }
            
            // Mostrar tooltip
            let tooltipContent = `<strong style="color:#243360; font-size:16px">${d.name}</strong>`;
            
            // Añadir información del grado
            tooltipContent += gradoTexto;
            
            if (d.level === 3) {
                tooltipContent += `<br><span style="color:#243360">Origen:</span> ${d.origen}`;
                tooltipContent += `<br><span style="color:#243360">Época:</span> ${d.epoca}`;
                
                // Añadir información sobre ingredientes principales
                const ingredientesPrincipales = INGREDIENTES_PRINCIPALES.filter(
                    ing => d.ingredientes && d.ingredientes.includes(ing)
                );
                
                if (ingredientesPrincipales.length > 0) {
                    tooltipContent += `<br><br><span style="color:#243360; font-weight:bold">Ingredientes principales:</span> <br>`;
                    ingredientesPrincipales.forEach(ing => {
                        tooltipContent += `<span style="color:#243360">${ing.toLowerCase()}</span>, `;
                    });
                    tooltipContent = tooltipContent.slice(0, -2); // Quitar la última coma
                }
            }
            
            tooltip
                .html(tooltipContent)
                .style('left', (event.pageX + 10) + 'px')
                .style('top', (event.pageY - 10) + 'px')
                .style('opacity', 1);
                
            // Mantener solo etiquetas de nivel 1 (no mostrar otras)
            labelElements.attr('opacity', n => n.level === 1 ? 1 : 0);
        })
        .on('mouseout', function() {
            // Restaurar estado normal
            d3.select(this)
                .attr('stroke', '#fff')
                .attr('stroke-width', 1);
                
            // Restaurar opacidad a 40% (0.4)
            linkElements.attr('opacity', d => {
                if (ingredienteActivo) {
                    return d.isRelevant ? 0.4 : 0.05;
                }
                return 0.4;
            });
            nodeElements.attr('opacity', 1);
            
            // Ocultar tooltip
            tooltip.style('opacity', 0);
            
            // Mantener solo etiquetas de nivel 1
            labelElements.attr('opacity', n => n.level === 1 ? 1 : 0);
        })
        .on('click', function(event, d) {
            // Fijar/desfijar nodo al hacer clic
            const isFixed = d.fx !== null || d.fy !== null;
            
            if (isFixed) {
                // Desfijar si ya estaba fijo
                d.fx = null;
                d.fy = null;
                d3.select(this).attr('stroke', '#fff');
            } else {
                // Fijar en su posición actual
                d.fx = d.x;
                d.fy = d.y;
                d3.select(this).attr('stroke', '#ff0');
            }
        });
    }
    
    // Vamos a mover la leyenda fuera del SVG para que no se pierda con el zoom
    
    // Añadir contenedor para controles (botón y leyenda)
    const controlsContainer = d3.select('#network')
        .append('div')
        .attr('class', 'graph-controls')
        .style('position', 'absolute')
        .style('top', '10px')
        .style('right', '10px')
        .style('display', 'flex')
        .style('align-items', 'center')
        .style('gap', '15px');
    
    // Añadir leyenda fuera del SVG
    const legendContainer = controlsContainer
        .append('div')
        .attr('class', 'graph-legend')
        .style('display', 'flex')
        .style('align-items', 'center')
        .style('gap', '5px');
        
    // Categorías de nodos con colores
    const legendItems = [
        { label: 'Épocas', color: '#243360' },
        { label: 'Orígenes', color: '#83572B' },
        { label: 'Platillos', color: '#608CA8' }
    ];
    
    // Crear cada elemento de la leyenda
    legendItems.forEach(item => {
        // Contenedor por ítem
        const itemContainer = legendContainer
            .append('div')
            .style('display', 'flex')
            .style('align-items', 'center')
            .style('margin-right', '10px');
            
        // Círculo de color
        itemContainer.append('div')
            .style('width', '10px')
            .style('height', '10px')
            .style('border-radius', '50%')
            .style('background-color', item.color)
            .style('margin-right', '4px');
            
        // Texto de la etiqueta
        itemContainer.append('span')
            .text(item.label)
            .style('font-size', '11px')
            .style('color', '#999')
            .style('font-family', 'Arial, sans-serif');
    });
    
    // Añadir botón de reset con nuevo texto
    const resetButton = controlsContainer
        .append('button')
        .attr('class', 'reset-button')
        .text('Todos los ingredientes')
        .style('background-color', '#243360')
        .style('color', 'white')
        .style('border', '1px solid #243360')
        .style('border-radius', '4px')
        .style('padding', '8px 12px')
        .style('cursor', 'pointer')
        .style('font-weight', 'bold')
        .style('box-shadow', '0 2px 4px rgba(0,0,0,0.1)')
        .on('click', function() {
            // Reiniciar grafo
            nodesFiltered.forEach(node => {
                node.fx = null;
                node.fy = null;
            });
            
            ingredienteActivo = null;
            filtrarPorIngrediente(null);
            actualizarVisualizacion();
            
            simulation.alpha(1).restart();
        });
    
    // Cargar y procesar los datos
    d3.text('./json/platillos_expandido.csv')
        .then(function(data) {
            // Parsear los datos CSV
            const rows = data.split('\n').slice(1); // Omitir encabezado
            
            console.log('Iniciando procesamiento de datos del CSV...');
            
            // Procesar los datos para crear la estructura del grafo
            const epocas = new Map(); // Nivel 1 (centro)
            const origenes = new Map(); // Nivel 2 (medio) - Ahora solo por nombre del origen
            const platillos = new Map(); // Nivel 3 (exterior)
            
            // Enlaces entre niveles
            links = [];
            
            // Conjunto para mantener registro de enlaces únicos
            const uniqueLinks = new Set();
            
            // Para el conteo de conexiones 
            const origenConnections = new Map(); // Contar conexiones por origen
            const epocaConnections = new Map(); // Contar conexiones por época
            
            // Mapa para almacenar la relación entre platillos e ingredientes
            const platillosIngredientes = new Map();
            
            // Lista para registrar todos los orígenes únicos encontrados (para depuración)
            const origenesUnicos = new Set();
            
            // Mapa para registrar las épocas asociadas a cada origen
            const origenEpocas = new Map();
            
            rows.forEach(row => {
                if (!row.trim()) return; // Saltar filas vacías
                
                const fields = row.split('|');
                if (fields.length < 14) return; // Verificar que tenga suficientes campos
                
                const nombrePlatillo = fields[0].trim();
                const origenPlatillo = fields[1].trim();
                const epocaPlatillo = fields[11].trim();
                const ingrediente = fields[13] ? fields[13].trim().toUpperCase() : '';
                
                // Saltear si algún campo esencial está vacío
                if (!nombrePlatillo || !origenPlatillo || !epocaPlatillo) return;
                
                // Registrar el origen único para depuración
                origenesUnicos.add(origenPlatillo);
                
                // Registrar la relación entre platillo e ingrediente
                const platilloKey = `${nombrePlatillo}-${origenPlatillo}`;
                if (ingrediente) {
                    if (!platillosIngredientes.has(platilloKey)) {
                        platillosIngredientes.set(platilloKey, new Set());
                    }
                    
                    // Guardar el ingrediente original completo
                    platillosIngredientes.get(platilloKey).add(ingrediente);
                }
                
                // 1. Añadir nodo de época si no existe
                if (!epocas.has(epocaPlatillo)) {
                    epocas.set(epocaPlatillo, {
                        id: epocaPlatillo,
                        name: epocaPlatillo,
                        level: 1, // Nivel 1: épocas (centro)
                        connections: 0
                    });
                    epocaConnections.set(epocaPlatillo, 0);
                }
                
                // 2. Añadir nodo de origen si no existe (usando solo el nombre)
                if (!origenes.has(origenPlatillo)) {
                    origenes.set(origenPlatillo, {
                        id: origenPlatillo,
                        name: origenPlatillo,
                        level: 2, // Nivel 2: orígenes (medio)
                        connections: 0,
                        epocas: new Set() // Para registrar con qué épocas está relacionado
                    });
                    origenConnections.set(origenPlatillo, 0);
                }
                
                // Registrar relación entre origen y época
                origenes.get(origenPlatillo).epocas.add(epocaPlatillo);
                
                // Registrar época asociada a este origen para enlaces
                if (!origenEpocas.has(origenPlatillo)) {
                    origenEpocas.set(origenPlatillo, new Set());
                }
                origenEpocas.get(origenPlatillo).add(epocaPlatillo);
                
                // 3. Añadir nodo de platillo si no existe
                if (!platillos.has(platilloKey)) {
                    platillos.set(platilloKey, {
                        id: platilloKey,
                        name: nombrePlatillo,
                        origen: origenPlatillo,
                        epoca: epocaPlatillo,
                        level: 3, // Nivel 3: platillos (exterior)
                        ingredientes: [] // Se llenará después
                    });
                    
                    // Crear enlace entre origen y platillo
                    const linkKeyOtP = `${origenPlatillo}-${platilloKey}`;
                    if (!uniqueLinks.has(linkKeyOtP)) {
                        links.push({
                            source: origenPlatillo,
                            target: platilloKey,
                            value: 1,
                            type: 'origen-platillo'
                        });
                        uniqueLinks.add(linkKeyOtP);
                        
                        // Incrementar contador de conexiones para el origen
                        if (origenConnections.has(origenPlatillo)) {
                            origenConnections.set(origenPlatillo, origenConnections.get(origenPlatillo) + 1);
                        }
                    }
                }
            });
            
            // Crear enlaces entre épocas y orígenes
            console.log(`Procesando ${origenEpocas.size} orígenes únicos`);
            
            // Esta parte es crucial para evitar nodos duplicados
            origenEpocas.forEach((epocasSet, origen) => {
                console.log(`Origen "${origen}" está relacionado con ${epocasSet.size} épocas`);
                
                epocasSet.forEach(epoca => {
                    const linkKeyEtO = `${epoca}-${origen}`;
                    if (!uniqueLinks.has(linkKeyEtO)) {
                        links.push({
                            source: epoca,
                            target: origen,
                            value: 1,
                            type: 'epoca-origen'
                        });
                        uniqueLinks.add(linkKeyEtO);
                        
                        // Incrementar conteo de conexiones para la época
                        if (epocaConnections.has(epoca)) {
                            epocaConnections.set(epoca, epocaConnections.get(epoca) + 1);
                        }
                    }
                });
            });
            
            // Actualizar el conteo de conexiones para los nodos
            epocas.forEach((node, key) => {
                node.connections = epocaConnections.get(key) || 0;
            });
            
            origenes.forEach((node, key) => {
                node.connections = origenConnections.get(key) || 0;
            });
            
            // Imprimir información para depuración
            console.log(`Total épocas: ${epocas.size}`);
            console.log(`Total orígenes: ${origenes.size}`);
            console.log(`Total platillos: ${platillos.size}`);
            console.log(`Total enlaces: ${links.length}`);
            console.log(`Orígenes únicos encontrados: ${origenesUnicos.size}`);
            
            // Completar la información de ingredientes para cada platillo
            platillos.forEach((platillo, key) => {
                if (platillosIngredientes.has(key)) {
                    platillo.ingredientes = Array.from(platillosIngredientes.get(key));
                } else {
                    platillo.ingredientes = [];
                }
            });
            
            // Convertir maps a arrays para D3
            nodes = [
                ...Array.from(epocas.values()),
                ...Array.from(origenes.values()),
                ...Array.from(platillos.values())
            ];
            
            // Inicialmente, mostrar todos los nodos
            nodesFiltered = [...nodes];
            linksFiltered = [...links];
            
            // Guardar datos para acceso externo
            window.grafoData = {
                nodes,
                links
            };
            
            // Inicializar visualización
            actualizarVisualizacion();
            
            // Notificar que el grafo está inicializado (con un pequeño retraso para asegurar que el DOM esté listo)
            setTimeout(() => {
                window.grafoInicializado = true;
                console.log('Grafo inicializado correctamente');
            }, 500);
            
            // Imprimir ingredientes encontrados para comprobar los datos
            console.log('Ingredientes clave detectados:');
            const ingredientesClave = ['MAIZ', 'MAÍZ', 'FRIJOL', 'FRÍJOL', 'CHILE', 'CALABAZA', 'CACAO'];
            ingredientesClave.forEach(ing => {
                // Contar platillos que contienen este ingrediente
                const platillosConIngrediente = Array.from(platillos.values()).filter(
                    platillo => platillo.ingredientes && platillo.ingredientes.includes(ing)
                ).length;
                
                console.log(`${ing}: ${platillosConIngrediente} platillos`);
            });
            
            // Verificar si ya hay un ingrediente seleccionado por scrollama
            if (window.currentIngredient) {
                console.log(`Usando ingrediente desde scrollama: ${window.currentIngredient}`);
                setTimeout(() => {
                    filtrarPorIngrediente(window.currentIngredient);
                    actualizarVisualizacion(false); // Sin forma de ingrediente
                }, 500);
            } else {
                // Si no hay ingrediente seleccionado, iniciamos con MAIZ como default
                const ingredienteInicial = 'MAIZ';
                console.log(`No hay ingrediente activo de scrollama, usando default: ${ingredienteInicial}`);
                setTimeout(() => {
                    filtrarPorIngrediente(ingredienteInicial);
                    actualizarVisualizacion(false); // Sin forma de ingrediente
                }, 800);
            }
        })
        .catch(function(error) {
            console.error('Error al cargar o procesar los datos:', error);
            d3.select('#network')
                .append('div')
                .attr('class', 'error-message')
                .style('color', '#243360')
                .style('background-color', '#f8d7da')
                .style('border', '1px solid #f5c6cb')
                .style('border-radius', '4px')
                .style('padding', '20px')
                .style('margin', '20px')
                .style('text-align', 'center')
                .style('font-weight', 'bold')
                .text('Error al cargar los datos. Por favor verifica la ruta y formato del archivo CSV.');
        });
    
    // Añadir integración con aperitivo.js para filtrar por ingrediente
    window.filtrarGrafoPorIngrediente = function(ingrediente) {
        // Verificar si el contenedor del grafo existe antes de filtrar
        if (!document.getElementById('network')) {
            console.error('Error: Contenedor del grafo no encontrado (#network)');
            // Intentar regenerar el grafo
            regenerateGraph();
            return;
        }
        
        // Filtrar con manejo de errores
        try {
            window.actualizarIngredienteGrafo(ingrediente);
        } catch (error) {
            console.error('Error al filtrar el grafo:', error);
        }
    };
    
    } // Fin de la función initGraph
    
    // Iniciar la creación del grafo
    initGraph();
    
    // También regenerar después de 1 segundo para asegurar que el DOM está listo
    setTimeout(regenerateGraph, 1000);
});