/**
 * Grafo circular en D3.js que muestra las relaciones entre:
 * - Nivel 1 (centro): Épocas de platillos
 * - Nivel 2 (medio): Orígenes de platillos
 * - Nivel 3 (exterior): Nombres de platillos
 * 
 * El grafo se filtra dinámicamente según el ingrediente en foco:
 * - Maíz, Frijol, Chile, Calabaza o Cacao
 */
// Esperamos a que el DOM esté completamente cargado
document.addEventListener('DOMContentLoaded', function() {
    console.log('Inicializando grafo circular...');
    
    // Función para asegurar que existe el contenedor
    function ensureContainer() {
        // Verificar si el contenedor existe
        let networkContainer = document.getElementById('network');
        
        // Si no existe, intentar encontrar o crear el contenedor
        if (!networkContainer) {
            console.log('Contenedor #network no encontrado, intentando crear uno...');
            
            // Buscar el contenedor .visualization-container
            const vizContainer = document.querySelector('.visualization-container');
            
            if (vizContainer) {
                console.log('Contenedor .visualization-container encontrado, creando #network dentro');
                networkContainer = document.createElement('div');
                networkContainer.id = 'network';
                networkContainer.style.width = '100%';
                networkContainer.style.height = '800px';
                networkContainer.style.border = '3px solid red';  // Borde visible para depuración
                networkContainer.style.backgroundColor = '#ffffff';
                vizContainer.innerHTML = ''; // Limpiar cualquier contenido previo
                vizContainer.appendChild(networkContainer);
            } else {
                console.error('No se encontró .visualization-container, no se puede crear el grafo');
                
                // Intentar buscar en .sticky-image-sankey
                const sankeyContainer = document.querySelector('.sticky-image-sankey');
                if (sankeyContainer) {
                    console.log('Contenedor .sticky-image-sankey encontrado, creando .visualization-container y #network dentro');
                    
                    // Crear visualization-container
                    const newVizContainer = document.createElement('div');
                    newVizContainer.className = 'visualization-container';
                    newVizContainer.style.width = '100%';
                    newVizContainer.style.height = '800px';
                    newVizContainer.style.border = '3px solid green';
                    
                    // Crear network dentro
                    networkContainer = document.createElement('div');
                    networkContainer.id = 'network';
                    networkContainer.style.width = '100%';
                    networkContainer.style.height = '800px';
                    networkContainer.style.border = '3px solid red';
                    networkContainer.style.backgroundColor = '#ffffff';
                    
                    // Añadir al DOM
                    newVizContainer.appendChild(networkContainer);
                    sankeyContainer.innerHTML = '';
                    sankeyContainer.appendChild(newVizContainer);
                }
            }
        } else {
            console.log('Contenedor #network encontrado correctamente');
        }
        
        return !!document.getElementById('network');
    }
    
    // Función para verificar si el grafo ya existe y regenerarlo
    function regenerateGraph() {
        // Verificar y asegurar que el contenedor existe
        if (ensureContainer()) {
            console.log('Verificando estado del grafo y regenerando si es necesario...');
            if (!document.querySelector('#network svg')) {
                console.log('Grafo no encontrado en el DOM, iniciando creación...');
                initGraph();
            }
        } else {
            console.error('No se pudo crear el contenedor para el grafo');
        }
    }
    
    // Llamar a regenerar el grafo cuando la página cambie de tamaño
    window.addEventListener('resize', regenerateGraph);
    
    // Asegurar contenedor inmediatamente
    ensureContainer();
    
    // Función principal de inicialización del grafo
    function initGraph() {
    // Asegurarse de que D3 está disponible
    if (!window.d3) {
        console.error('D3.js no está cargado. Por favor incluya la biblioteca D3 antes de este script.');
        return;
    }
    
    // Verificar que el contenedor del grafo existe
    const networkContainer = document.getElementById('network');
    if (!networkContainer) {
        console.error('Error: No se encontró el contenedor #network para el grafo circular.');
        
        // Intentar crear el contenedor si no existe
        const vizContainer = document.querySelector('.visualization-container');
        if (vizContainer) {
            console.log('Creando contenedor #network dentro de .visualization-container');
            const newNetworkDiv = document.createElement('div');
            newNetworkDiv.id = 'network';
            newNetworkDiv.style.width = '100%';
            newNetworkDiv.style.height = '800px'; // Altura suficiente para visualizar
            vizContainer.appendChild(newNetworkDiv);
        } else {
            console.error('No se encontró ni siquiera el contenedor .visualization-container');
            return; // No podemos continuar sin un contenedor
        }
    } else {
        console.log('Contenedor #network encontrado correctamente');
    }
    
    // Ingredientes principales para filtrado
    const INGREDIENTES_PRINCIPALES = [
        'MAÍZ', 'FRIJOL', 'CHILE', 'CALABAZA', 'CACAO'
    ];
    
    // Variable global para el ingrediente actualmente seleccionado
    let ingredienteActivo = null;
    
    // Dimensiones y configuración - Adaptamos al contenedor y pantalla disponible
    const container = document.getElementById('network');
    const containerWidth = container.clientWidth || window.innerWidth * 0.75;
    const containerHeight = container.clientHeight || window.innerHeight * 0.8;
    
    // Utilizar todo el espacio disponible sin exceder el contenedor
    const width = containerWidth - 40; // Margen para evitar cortes
    const height = containerHeight - 40; // Margen para evitar cortes
    
    console.log(`Creando grafo con dimensiones: ${width}x${height}`);
    
    // Radio proporcional a la dimensión más pequeña - reducido para dar más espacio
    const radius = Math.min(width, height) / 2 - 100;
    
    // Radios para cada nivel - Ajustados para mejor visibilidad y más espacio
    const radiusLevel1 = radius * 0.2; // Centro más pequeño
    const radiusLevel2 = radius * 0.5; // Nivel medio más compacto
    const radiusLevel3 = radius * 0.85; // Exterior ligeramente más cercano
    
    // Establecer dimensiones del contenedor
    container.style.width = '100%';
    container.style.height = '100%';
    
    // Limpiar el contenedor antes de crear el SVG
    d3.select('#network').html('');
    
    console.log('Creando el SVG para el grafo circular...');
    
    // Crear el contenedor SVG con funcionalidad de zoom (sin borde)
    const zoomContainer = d3.select('#network')
        .append('svg')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('style', 'max-width: 100%; height: auto; background-color: white;'); // Sin borde
        
    // Añadir grupo principal que será afectado por el zoom
    const svg = zoomContainer.append('g')
        .attr('transform', `translate(${Math.floor(width / 2)}, ${Math.floor(height / 2)})`);
        
    // Configurar el zoom
    const zoom = d3.zoom()
        .scaleExtent([0.5, 5])  // Limita el nivel de zoom entre 0.5x y 5x
        .on("zoom", (event) => {
            svg.attr("transform", `translate(${width/2 + event.transform.x}, ${height/2 + event.transform.y}) scale(${event.transform.k})`);
        });
        
    // Activar el zoom en el SVG
    zoomContainer.call(zoom);
    
    // Añadir instrucciones de zoom
    zoomContainer.append('text')
        .attr('x', 20)
        .attr('y', 30)
        .attr('fill', '#243360')
        .style('font-size', '14px')
        .text('Usa la rueda del ratón para hacer zoom y arrastrar para mover');

    // Quitamos el título del SVG ya que se pierde al hacer zoom

    // Crear grupo para los círculos guía (opcional, para referencia visual)
    const guideCircles = svg.append('g').attr('class', 'guide-circles');
    
    // Círculos guía (opcional) - Color adaptado para fondo blanco
    guideCircles.append('circle')
        .attr('r', radiusLevel1)
        .attr('fill', 'none')
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,4')
        .attr('opacity', 0.5);
        
    guideCircles.append('circle')
        .attr('r', radiusLevel2)
        .attr('fill', 'none')
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,4')
        .attr('opacity', 0.5);
        
    guideCircles.append('circle')
        .attr('r', radiusLevel3)
        .attr('fill', 'none')
        .attr('stroke', '#ccc')
        .attr('stroke-width', 1)
        .attr('stroke-dasharray', '4,4')
        .attr('opacity', 0.5);

    // Crear grupos principales para los elementos visuales
    const linkGroup = svg.append('g').attr('class', 'links');
    const nodeGroup = svg.append('g').attr('class', 'nodes');
    const labelGroup = svg.append('g').attr('class', 'labels');
    
    // Variables globales
    let simulation;
    let nodes = [];
    let links = [];
    let nodesFiltered = [];
    let linksFiltered = [];
    let nodeElements, linkElements, labelElements;
    
    // Función para actualizar el ingrediente activo (expuesta globalmente)
    window.actualizarIngredienteGrafo = function(ingrediente) {
        console.log('Filtrar grafo por ingrediente:', ingrediente);
        
        // Si no hay ingrediente o está vacío, mostrar grafo completo
        if (!ingrediente || ingrediente.trim() === '') {
            console.log('Ingrediente vacío o nulo, mostrando grafo completo');
            ingredienteActivo = null;
        } else {
            // Simplemente convertir a mayúsculas para la búsqueda
            ingredienteActivo = ingrediente.trim().toUpperCase();
            
            // Simplificar para los 5 ingredientes principales
            if (ingredienteActivo === 'MAÍZ') ingredienteActivo = 'MAÍZ';
            if (ingredienteActivo === 'FRÍJOL') ingredienteActivo = 'FRIJOL';
            
            console.log('Ingrediente normalizado para búsqueda:', ingredienteActivo);
        }
        if (window.grafoData && window.grafoInicializado) {
            // El grafo está inicializado, podemos filtrar
            filtrarPorIngrediente(ingredienteActivo);
            actualizarVisualizacion(false); // Sin forma de ingrediente
        } else {
            console.log('Esperando a que el grafo se inicialice para filtrar por:', ingrediente);
            // Intentar de nuevo después de un breve retraso si los datos están disponibles pero no inicializado
            if (window.grafoData && !window.grafoInicializado) {
                setTimeout(() => {
                    if (window.grafoInicializado) {
                        filtrarPorIngrediente(ingredienteActivo);
                        actualizarVisualizacion(false); // Sin forma de ingrediente
                    }
                }, 500);
            }
        }
    };
    
    // Función para determinar colores de los nodos según el nivel
    function getNodeColor(node) {
        if (node.level === 1) return '#243360';  // Época (centro)
        if (node.level === 2) return '#83572B';  // Origen (medio)
        
        // Todos los platillos (nivel 3) del mismo color
        return '#608CA8';
    }
    
    // Función para determinar el tamaño de los nodos - Recalculado según el grafo filtrado
    function getNodeRadius(node) {
        // Calcular el número de conexiones en el grafo filtrado actual
        let connectionCount = 0;
        
        // Contar las conexiones en los enlaces filtrados
        linksFiltered.forEach(link => {
            const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
            const targetId = typeof link.target === 'object' ? link.target.id : link.target;
            
            if (sourceId === node.id || targetId === node.id) {
                connectionCount++;
            }
        });
        
        // Aplicar escala según el nivel
        if (node.level === 1) {
            // Épocas: más grandes
            return Math.max(14, Math.min(40, 15 + connectionCount));
        }
        if (node.level === 2) {
            // Orígenes: tamaño medio
            return Math.max(10, Math.min(20, 10 + connectionCount / 3));
        }
        
        // Platillos: tamaño pequeño pero uniforme
        return 6;
    }
    
    // Funciones para controlar el arrastre de nodos
    function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }
    
    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        // No resetear d.fx y d.fy para mantener la posición
    }
    
    // Crear tooltip mejorado
    const tooltip = d3.select('body').append('div')
        .attr('class', 'graph-tooltip')
        .style('position', 'absolute')
        .style('color', '#333') // Texto oscuro
        .style('font-size', '12px')
        .style('pointer-events', 'none')
        .style('opacity', 0)
        .style('transition', 'opacity 0.2s linear');
    
    // Función para filtrar por ingrediente según el scroll
    function filtrarPorIngrediente(ingrediente) {
        if (!window.grafoData) {
            console.warn('No hay datos de grafo disponibles para filtrar');
            return;
        }
        
        // Actualizamos el ingrediente activo
        ingredienteActivo = ingrediente;
        
        console.log(`Actualizando filtro - Ingrediente activo: ${ingredienteActivo}`);
        
        // Si no hay ingrediente activo (último paso), mostrar todo el grafo
        if (!ingredienteActivo) {
            console.log('Mostrando grafo completo sin filtros');
            nodesFiltered = [...nodes];
            linksFiltered = [...links];
            actualizarVisualizacion(false); // Sin forma especial para grafo completo
            return;
        }
        
        console.log(`Filtrando grafo por ingrediente: ${ingredienteActivo}`);
        
        // ================ FILTRADO ESTRICTO ================
        // Solo mostrar los nodos y enlaces relacionados con este ingrediente
        
        // Paso 1: Identificar platillos que contienen el ingrediente específico
        const platillosConIngrediente = new Set();
        
        console.log(`Buscando platillos con ingrediente que contenga: ${ingredienteActivo}`);
        
        nodes.forEach(node => {
            if (node.level === 3 && node.ingredientes && node.ingredientes.length > 0) {
                // Buscar si alguno de los ingredientes CONTIENE el texto buscado
                // Por ejemplo, "CHILE SECO" contiene "CHILE"
                const tieneIngrediente = node.ingredientes && Array.isArray(node.ingredientes) && 
                    node.ingredientes.some(ing => 
                        ing && typeof ing === 'string' && ing.includes(ingredienteActivo)
                    );
                
                if (tieneIngrediente) {
                    platillosConIngrediente.add(node.id);
                    node.isRelevant = true; // Marcar como relevante
                } else {
                    node.isRelevant = false;
                }
            } else if (node.level === 3) {
                node.isRelevant = false;
            }
        });
        
        console.log(`Encontrados ${platillosConIngrediente.size} platillos con ingrediente: ${ingredienteActivo}`);
        
        // Paso 2: Identificar orígenes relacionados con estos platillos
        const origenesRelacionados = new Set();
        const enlacesOrigenPlatillo = [];
        
        links.forEach(link => {
            // Verificar si es un enlace entre origen y platillo
            if (link.type === 'origen-platillo') {
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                if (platillosConIngrediente.has(targetId)) {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    origenesRelacionados.add(sourceId);
                    enlacesOrigenPlatillo.push(link); // Guardar este enlace
                }
            }
        });
        
        console.log(`Encontrados ${origenesRelacionados.size} orígenes relacionados con ${ingredienteActivo}`);
        
        // Marcar orígenes como relevantes
        nodes.forEach(node => {
            if (node.level === 2) {
                node.isRelevant = origenesRelacionados.has(node.id);
            }
        });
        
        // Paso 3: Identificar épocas relacionadas con estos orígenes
        const epocasRelacionadas = new Set();
        const enlacesEpocaOrigen = [];
        
        links.forEach(link => {
            if (link.type === 'epoca-origen') {
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                if (origenesRelacionados.has(targetId)) {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    epocasRelacionadas.add(sourceId);
                    enlacesEpocaOrigen.push(link); // Guardar este enlace
                }
            }
        });
        
        console.log(`Encontradas ${epocasRelacionadas.size} épocas relacionadas con ${ingredienteActivo}`);
        
        // Marcar épocas como relevantes
        nodes.forEach(node => {
            if (node.level === 1) {
                node.isRelevant = epocasRelacionadas.has(node.id);
            }
        });
        
        // Paso 4: Crear la lista filtrada de nodos y enlaces
        
        // Filtrar solo los nodos relevantes
        nodesFiltered = nodes.filter(node => {
            if (node.level === 1) return epocasRelacionadas.has(node.id);
            if (node.level === 2) return origenesRelacionados.has(node.id);
            if (node.level === 3) return platillosConIngrediente.has(node.id);
            return false;
        });
        
        // Combinar los enlaces relevantes
        linksFiltered = [...enlacesEpocaOrigen, ...enlacesOrigenPlatillo];
        
        // Ajustar opacidad en los enlaces filtrados
        linksFiltered.forEach(link => {
            link.isRelevant = true;
            link.opacity = 0.4; // Opacidad 40% para los enlaces relevantes
        });
        
        console.log(`Filtrado completado: ${nodesFiltered.length} nodos y ${linksFiltered.length} enlaces relevantes`);
        
        // Si no hay suficientes elementos para mostrar, volver al filtrado original
        if (nodesFiltered.length < 5 || linksFiltered.length < 4) {
            console.log('Muy pocos elementos para mostrar, volviendo al filtrado visual');
            
            // Revertir al filtrado visual (original)
            nodesFiltered = [...nodes];
            linksFiltered = [...links];
            
            // Marcar enlaces como relevantes o no
            linksFiltered.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                
                if (link.type === 'epoca-origen') {
                    // Enlace entre época y origen
                    link.isRelevant = epocasRelacionadas.has(sourceId) && origenesRelacionados.has(targetId);
                } else if (link.type === 'origen-platillo') {
                    // Enlace entre origen y platillo
                    link.isRelevant = origenesRelacionados.has(sourceId) && platillosConIngrediente.has(targetId);
                } else {
                    link.isRelevant = false;
                }
                
                // Marcar el enlace como invisible si no es relevante
                link.opacity = link.isRelevant ? 0.4 : 0.05; // 40% para enlaces relevantes
            });
        }
    }
    
    // Código de máscaras SVG eliminado
    
    // Obtener coordenadas para formar la silueta de un ingrediente
